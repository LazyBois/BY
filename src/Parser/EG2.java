/* Generated By:JJTree&JavaCC: Do not edit this line. EG2.java */
package Parser;

import java.text.SimpleDateFormat;
import java.util.*;
import java.io.*;
import sd.*;
import util.*;



public class EG2/*@bgen(jjtree)*/implements EG2TreeConstants, EG2Constants {/*@bgen(jjtree)*/
  protected static JJTEG2State jjtree = new JJTEG2State();public static int row = 0;
   public static FHTable fh = null;

  public static PrintStream fs = null;

  public static QTTable qtTable = null;

  public static SimpleNode n = null;

  public static String ErrorOutputName = "ErrorLog.txt";

  public static void main(String args [])
  {

        sd window = new sd();
        window.frame.setVisible(true);

    qtTable = new QTTable();
     fh = new FHTable();

    String fileTOutputName = "testToken.txt"; //词法
    String fileGOutputName = "testGrammar.txt"; //语法
    String fileInputName = "";
    System.out.print("Enter filePath:");
    Scanner in = new Scanner(System.in);
    //    fileInputName = in.next();
    fileInputName = "test.txt";
    FileInputStream fis = null;
    try
    {
         PrintStream randomFile = new PrintStream(ErrorOutputName);
    randomFile.println("\u9519\u8bef");
    randomFile.flush();
    randomFile.close();
    SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    appendMethodA(ErrorOutputName, df.format(new Date()));


      fis = new FileInputStream(fileInputName);
      new EG2(fis);
      n = EG2.Start();
      fs = new PrintStream(fileGOutputName);
      dump("", n);
      fis = new FileInputStream(fileInputName);
      SimpleCharStream.inputStream = null;
      SimpleCharStream SCS = new SimpleCharStream(fis, null, 1, 1);
      EG2TokenManager.ReInit(SCS);
      fs = new PrintStream(fileTOutputName);
      getToken();
      fis.close();
      qtTable.printQTTable();
      System.out.println("Thank you.");
        appendMethodA(ErrorOutputName, "Over!");
    }
    catch (Exception e)
    {
      System.out.println("\u7a0b\u5e8f\u51fa\u9519\uff01\u8bf7\u67e5\u770b\u9519\u8bef\u65e5\u5fd7\uff01");
      appendMethodA(ErrorOutputName, e.getMessage());
    }
  }

public static void appendMethodA(String fileName, String content)
  {
    try
    {
      // 打开一个随机访问文件流，按读写方式  
      RandomAccessFile randomFile = new RandomAccessFile(fileName, "rw");
      // 文件长度，字节数  
      long fileLength = randomFile.length();
      //将写文件指针移到文件尾。  
      randomFile.seek(fileLength);
      randomFile.writeBytes("\u005cn");
      randomFile.writeBytes(content);
      randomFile.close();
    }
    catch (IOException e)
    {
      e.printStackTrace();
    }
  }

  public static void getToken()
  {
    Token t = EG2TokenManager.getNextToken();
    while (!t.image.equals(""))
    {
      fs.println("(" + "\u201c" + t.image + "\u201d" + "," + t.kind + ")");
      t = EG2TokenManager.getNextToken();
    }
    fs.flush();
    fs.close();
  }

  public static void dump(String prefix, SimpleNode n)
  {
    //System.out.println(toString(prefix));
    fs.println(prefix + EG2TreeConstants.jjtNodeName [n.id]);
    if (n.children != null)
    {
      for (int i = 0; i < n.children.length; ++i)
      {
        SimpleNode n1 = (SimpleNode) n.children [i];
        if (n1 != null)
        {
          dump(prefix + " ", n1);
        }
        else
        {
          fs.flush();
          fs.close();
        }
      }
    }
  }

  static final public SimpleNode Start() throws ParseException {
 /*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      pragram();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void pragram() throws ParseException {
 /*@bgen(jjtree) pragram */
  SimpleNode jjtn000 = new SimpleNode(JJTPRAGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VOID:
        case Int:
        case Double:
        case Float:
        case SHORT:
        case LONG:
        case Char:
        case Bool:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        Funtion();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Funtion() throws ParseException {
 /*@bgen(jjtree) Funtion */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      type();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        Identifier();
        break;
      case Main:
        jj_consume_token(Main);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LC);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VOID:
        case Int:
        case Double:
        case Float:
        case SHORT:
        case LONG:
        case Char:
        case Bool:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        type();
        Identifier();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case assign:
          jj_consume_token(assign);
          Integer();
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case comma:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_3;
          }
          jj_consume_token(comma);
          type();
          Identifier();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case assign:
            jj_consume_token(assign);
            Integer();
            break;
          default:
            jj_la1[5] = jj_gen;
            ;
          }
        }
      }
      jj_consume_token(RC);
      jj_consume_token(Lbrace);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case DO:
        case WHILE:
        case SWITCH:
        case BREAK:
        case RETURN:
        case CONTINUE:
        case doubleadd:
        case doublesub:
        case LC:
        case Lbrace:
        case VOID:
        case Int:
        case Double:
        case Float:
        case SHORT:
        case LONG:
        case Char:
        case Bool:
        case semicolon:
        case FLOATCONSTANT:
        case DOUBLECONSTANT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_4;
        }
        Block();
      }
      jj_consume_token(Rbrace);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Block() throws ParseException {
 /*@bgen(jjtree) Block */
  SimpleNode jjtn000 = new SimpleNode(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case FOR:
      case DO:
      case WHILE:
      case SWITCH:
      case BREAK:
      case RETURN:
      case CONTINUE:
      case doubleadd:
      case doublesub:
      case LC:
      case VOID:
      case Int:
      case Double:
      case Float:
      case SHORT:
      case LONG:
      case Char:
      case Bool:
      case semicolon:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        State();
        break;
      case Lbrace:
        jj_consume_token(Lbrace);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IF:
          case FOR:
          case DO:
          case WHILE:
          case SWITCH:
          case BREAK:
          case RETURN:
          case CONTINUE:
          case doubleadd:
          case doublesub:
          case LC:
          case Lbrace:
          case VOID:
          case Int:
          case Double:
          case Float:
          case SHORT:
          case LONG:
          case Char:
          case Bool:
          case semicolon:
          case FLOATCONSTANT:
          case DOUBLECONSTANT:
          case INTEGER_LITERAL:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[7] = jj_gen;
            break label_5;
          }
          Block();
        }
        jj_consume_token(Rbrace);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void State() throws ParseException {
 /*@bgen(jjtree) State */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
      case LC:
      case VOID:
      case Int:
      case Double:
      case Float:
      case SHORT:
      case LONG:
      case Char:
      case Bool:
      case semicolon:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        seqStatement();
        break;
      case FOR:
      case DO:
      case WHILE:
        loopStatement();
        break;
      case IF:
      case SWITCH:
        selStatement();
        break;
      case BREAK:
      case RETURN:
      case CONTINUE:
        jumpS();
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void seqStatement() throws ParseException {
 /*@bgen(jjtree) seqStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSEQSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
      case LC:
      case VOID:
      case Int:
      case Double:
      case Float:
      case SHORT:
      case LONG:
      case Char:
      case Bool:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case doubleadd:
        case doublesub:
        case LC:
        case FLOATCONSTANT:
        case DOUBLECONSTANT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
          assiState();
          break;
        case VOID:
        case Int:
        case Double:
        case Float:
        case SHORT:
        case LONG:
        case Char:
        case Bool:
          declState();
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jj_consume_token(semicolon);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void assiState() throws ParseException {
 /*@bgen(jjtree) assiState */
  SimpleNode jjtn000 = new SimpleNode(JJTASSISTATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str1;
  String str2;
  Token t = null;
    try {
      str1 = Express();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case assign:
        t = jj_consume_token(assign);
        str2 = Express();
      qtTable.addQTInfo(new QTInfo(t.image, str2, "_", str1));
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case comma:
            ;
            break;
          default:
            jj_la1[12] = jj_gen;
            break label_6;
          }
          jj_consume_token(comma);
          str1 = Express();
          t = jj_consume_token(assign);
          str2 = Express();
        qtTable.addQTInfo(new QTInfo(t.image, str2, "_", str1));
        }
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void declState() throws ParseException {
 /*@bgen(jjtree) declState */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLSTATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str1;
  String str2;
  String ty;
  Token t = null;
    try {
      ty = type();
               fh.add("notID", ty);
      str1 = Identifier();
    if (fh.has(str1))
    {
      String error = "Identifier " + str1 + " had been declared!";
      appendMethodA(ErrorOutputName, error);
      fh.remove("notID");
    }
    else
    {
      fh.set("notID", str1);
    }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case assign:
        t = jj_consume_token(assign);
        str2 = Express();
      qtTable.addQTInfo(new QTInfo(t.image, str2, "_", str1));
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_7;
        }
        jj_consume_token(comma);
     fh.add("notID", ty);
        str1 = Identifier();
    if (fh.has(str1))
    {
      String error = "Identifier " + str1 + " had been declared!";
      appendMethodA(ErrorOutputName, error);
      fh.remove("notID");
    }
    else
    {
      fh.set("notID", str1);
    }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case assign:
          t = jj_consume_token(assign);
          str2 = Express();
        qtTable.addQTInfo(new QTInfo(t.image, str2, "_", str1));
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//选择语句
  static final public void selStatement() throws ParseException {
 /*@bgen(jjtree) selStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSELSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        IFState();
        break;
      case SWITCH:
        Switchh();
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Switchh() throws ParseException {
 /*@bgen(jjtree) Switchh */
  SimpleNode jjtn000 = new SimpleNode(JJTSWITCHH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cv = new ConditionValue();
  Token tID = null;
  Token tcase = null;
  QTInfo qtT = null;
  QTInfo qtF = null;
  int nxq = 0;
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LC);
      tID = jj_consume_token(IDENTIFIER);
      jj_consume_token(RC);
      jj_consume_token(Lbrace);
      label_8:
      while (true) {
        jj_consume_token(CASE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHARCONSTANT:
          tcase = jj_consume_token(CHARCONSTANT);
          break;
        case INTEGER_LITERAL:
          tcase = jj_consume_token(INTEGER_LITERAL);
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(colon);
      nxq = QTInfo.innerIdSeqen + 1;
      qtT = new QTInfo("case", tID.image, tcase.image, nxq + 2);
      qtTable.addQTInfo(qtT);
      qtF = new QTInfo("j", "_", "_", 0);
      cv.mergeFalse(qtF);
      qtTable.addQTInfo(qtF);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IF:
          case FOR:
          case DO:
          case WHILE:
          case SWITCH:
          case BREAK:
          case RETURN:
          case CONTINUE:
          case doubleadd:
          case doublesub:
          case LC:
          case VOID:
          case Int:
          case Double:
          case Float:
          case SHORT:
          case LONG:
          case Char:
          case Bool:
          case semicolon:
          case FLOATCONSTANT:
          case DOUBLECONSTANT:
          case INTEGER_LITERAL:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[19] = jj_gen;
            break label_9;
          }
          State();
        }
      QTInfo qtJ = new QTInfo("jbr", "_", "_", 0);
      cv.mergeTrue(qtJ);
      qtTable.addQTInfo(qtJ);
      cv.backpatchFalseChain(QTInfo.innerIdSeqen + 1);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_8;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFAUL:
        jj_consume_token(DEFAUL);
        jj_consume_token(colon);
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IF:
          case FOR:
          case DO:
          case WHILE:
          case SWITCH:
          case BREAK:
          case RETURN:
          case CONTINUE:
          case doubleadd:
          case doublesub:
          case LC:
          case VOID:
          case Int:
          case Double:
          case Float:
          case SHORT:
          case LONG:
          case Char:
          case Bool:
          case semicolon:
          case FLOATCONSTANT:
          case DOUBLECONSTANT:
          case INTEGER_LITERAL:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[21] = jj_gen;
            break label_10;
          }
          State();
        }
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      jj_consume_token(Rbrace);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    cv.backpatchTrueChain(QTInfo.innerIdSeqen + 1);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void IFState() throws ParseException {
 /*@bgen(jjtree) IFState */
  SimpleNode jjtn000 = new SimpleNode(JJTIFSTATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int nxq = 0;
  ConditionValue cv = null;
  QTInfo qt = null;
    try {
      jj_consume_token(IF);
      jj_consume_token(LC);
      cv = BoolExpress();
      jj_consume_token(RC);
    nxq = QTInfo.innerIdSeqen + 1;
    cv.backpatchTrueChain(nxq);
      Block();
    qt = new QTInfo("j", "_", "_", 0);
    cv.mergeTrue(qt);
    qtTable.addQTInfo(qt);
    nxq = QTInfo.innerIdSeqen + 1;
    cv.backpatchFalseChain(nxq);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        Block();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    nxq = QTInfo.innerIdSeqen + 1;
    cv.backpatchTrueChain(nxq);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public ConditionValue BoolExpress() throws ParseException {
 /*@bgen(jjtree) BoolExpress */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEXPRESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cv = null;
    try {
      cv = orFunc();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return cv;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//或函数
  static final public ConditionValue orFunc() throws ParseException {
 /*@bgen(jjtree) orFunc */
  SimpleNode jjtn000 = new SimpleNode(JJTORFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int nxq = 0;
  ConditionValue cv1 = null;
  ConditionValue cv2 = null;
    try {
      cv1 = andFunc();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case oror:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_11;
        }
        jj_consume_token(oror);
      nxq = QTInfo.innerIdSeqen + 1;
      cv1.backpatchFalseChain(nxq);
        cv2 = andFunc();
      cv1.addAll(cv2);
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return cv1;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//且函数
  static final public ConditionValue andFunc() throws ParseException {
 /*@bgen(jjtree) andFunc */
  SimpleNode jjtn000 = new SimpleNode(JJTANDFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int nxq = 0;
  ConditionValue cv1 = null;
  ConditionValue cv2 = null;
    try {
      cv1 = notFunc();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case andand:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_12;
        }
        jj_consume_token(andand);
      nxq = QTInfo.innerIdSeqen + 1;
      cv1.backpatchTrueChain(nxq);
        cv2 = notFunc();
      cv1.addAll(cv2);
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return cv1;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public ConditionValue notFunc() throws ParseException {
 /*@bgen(jjtree) notFunc */
  SimpleNode jjtn000 = new SimpleNode(JJTNOTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cv = null;
  QTInfo qtTrue = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
      case LC:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        cv = Boolean();
        break;
      case exclamation:
        jj_consume_token(exclamation);
        cv = Boolean();
    cv.change();
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return cv;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public ConditionValue Boolean() throws ParseException {
 /*@bgen(jjtree) Boolean */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int nxq = 0;
  String str1 = "";
  String str2 = "";
  String s = "";
  ConditionValue cv = new ConditionValue();
  QTInfo qtTrue = null;
    try {
      str1 = Express();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case equal:
      case noEqual:
      case less:
      case over:
      case overEqual:
      case lessEqual:
        s = Relation();
        str2 = Express();
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    nxq = QTInfo.innerIdSeqen + 1;
    if (s.equals("")) qtTrue = new QTInfo("jnz", str1, "_", 0);
    else qtTrue = new QTInfo("j" + s, str1, str2, 0);
    QTInfo qtFalse = new QTInfo("j", "_", "_", 0);
    qtTable.addQTInfo(qtTrue);
    qtTable.addQTInfo(qtFalse);
    cv.mergeTrue(qtTrue);
    cv.mergeFalse(qtFalse);
    {if (true) return cv;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//循环语句
  static final public void loopStatement() throws ParseException {
 /*@bgen(jjtree) loopStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOPSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHILE:
        loopState();
        break;
      case DO:
        doLoop();
        break;
      case FOR:
        forLoop();
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void forLoop() throws ParseException {
 /*@bgen(jjtree) forLoop */
  SimpleNode jjtn000 = new SimpleNode(JJTFORLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int start = 0;
  int end = 0;
  int nxq = 0;
  int n = 0;
  int nxq2 = 0;
  ConditionValue cv = null;
  ArrayList < QTInfo > array3 = new ArrayList < QTInfo > ();
    try {
      jj_consume_token(FOR);
      jj_consume_token(LC);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
      case LC:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        assiState();
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      jj_consume_token(semicolon);
    nxq2 = QTInfo.innerIdSeqen + 1;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
      case exclamation:
      case LC:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        cv = BoolExpress();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(semicolon);
    start = QTInfo.innerIdSeqen + 1;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
      case LC:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        if (jj_2_1(2)) {
          assiState();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case doubleadd:
          case doublesub:
          case LC:
          case FLOATCONSTANT:
          case DOUBLECONSTANT:
          case INTEGER_LITERAL:
          case IDENTIFIER:
            Express();
            break;
          default:
            jj_la1[31] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      jj_consume_token(RC);
    {
      end = QTInfo.innerIdSeqen + 1;
    }
    if (cv != null) cv.backpatchTrueChain(start);
      Block();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    n = end - start;
    while ((n--) > 0)
    {
      array3.add(qtTable.QTList.get(start - 1));
      qtTable.QTList.remove(start - 1);
    }
    for (int i = start - 1; i < qtTable.QTList.size(); i++)
    {
      qtTable.get(i).setInnerId(i + 1);
    }
    for (int i = 0; i < array3.size(); i++)
    {
      array3.get(i).setInnerId(qtTable.QTList.size() + i + 1);
    }
    qtTable.QTList.addAll(array3);
    qtTable.addQTInfo(new QTInfo("j", "_", "_", nxq2));
    if (cv != null) cv.backpatchFalseChain(QTInfo.innerIdSeqen + 1);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void doLoop() throws ParseException {
 /*@bgen(jjtree) doLoop */
  SimpleNode jjtn000 = new SimpleNode(JJTDOLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int nxq = QTInfo.innerIdSeqen+ 1;
  int row = 0;
  ConditionValue cv = null;
    try {
      jj_consume_token(DO);
      Block();
      jj_consume_token(WHILE);
      jj_consume_token(LC);
      cv = BoolExpress();
      jj_consume_token(RC);
      jj_consume_token(semicolon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    cv.backpatchTrueChain(nxq);
    row = QTInfo.innerIdSeqen + 1;
    cv.backpatchFalseChain(row);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void loopState() throws ParseException {
 /*@bgen(jjtree) loopState */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOPSTATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cv = null;
  int nxq = 0;
  int start = 0;
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LC);
    start = QTInfo.innerIdSeqen + 1;
      cv = BoolExpress();
      jj_consume_token(RC);
    nxq = QTInfo.innerIdSeqen + 1;
    cv.backpatchTrueChain(nxq);
      Block();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    qtTable.addQTInfo(new QTInfo("j", "_", "_", start));
    nxq = QTInfo.innerIdSeqen + 1;
    cv.backpatchFalseChain(nxq);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//表达式
  static final public String Express() throws ParseException {
 /*@bgen(jjtree) Express */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = "";
    try {
      str = AdditiveExpression();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return str;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//加函数
  static final public String AdditiveExpression() throws ParseException {
 /*@bgen(jjtree) AdditiveExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
  String str1 = "";
  String str2 = "";
  String newTemp = "";
    try {
      str1 = MultiplicativeExpression();
    newTemp = str1;
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case add:
        case sub:
        case and:
        case or:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_13;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case add:
          t = jj_consume_token(add);
          break;
        case sub:
          t = jj_consume_token(sub);
          break;
        case and:
          t = jj_consume_token(and);
          break;
        case or:
          t = jj_consume_token(or);
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        str2 = MultiplicativeExpression();
      newTemp = VariableNameGenerator.genVariableName();
      qtTable.addQTInfo(new QTInfo(t.image, str1, str2, newTemp));
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return newTemp;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//乘函数
  static final public String MultiplicativeExpression() throws ParseException {
 /*@bgen(jjtree) MultiplicativeExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
  String str1 = "";
  String str2 = "";
  String newTemp = "";
  String op = "";
    try {
      str1 = UnaryExpression();
    newTemp = str1;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case doubleadd:
          jj_consume_token(doubleadd);
      op = "+";
          break;
        case doublesub:
          jj_consume_token(doublesub);
      op = "-";
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
    if (!op.equals(""))
    {
      newTemp = VariableNameGenerator.genVariableName();
      qtTable.addQTInfo(new QTInfo("=", str1, "_", newTemp));
      qtTable.addQTInfo(new QTInfo(op, str1, "1", str1));
      str1 = newTemp;
    }
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case mul:
        case div:
        case sig:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_14;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case mul:
          t = jj_consume_token(mul);
          break;
        case div:
          t = jj_consume_token(div);
          break;
        case sig:
          t = jj_consume_token(sig);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        str2 = UnaryExpression();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case doubleadd:
        case doublesub:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case doubleadd:
            jj_consume_token(doubleadd);
        op = "+";
            break;
          case doublesub:
            jj_consume_token(doublesub);
        op = "-";
            break;
          default:
            jj_la1[39] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[40] = jj_gen;
          ;
        }
      if (!op.equals(""))
      {
        newTemp = VariableNameGenerator.genVariableName();
        qtTable.addQTInfo(new QTInfo("=", str2, "_", newTemp));
        qtTable.addQTInfo(new QTInfo(op, str2, "1", str2));
        str2 = newTemp;
      }
      newTemp = VariableNameGenerator.genVariableName();
      qtTable.addQTInfo(new QTInfo(t.image, str1, str2, newTemp));
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return newTemp;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//操作符
  static final public String UnaryExpression() throws ParseException {
 /*@bgen(jjtree) UnaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = "";

  String str1 = "";
  boolean isID = true;
    try {
      if (jj_2_2(2)) {
        str = callFunc();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          str = Identifier();
          break;
        case doubleadd:
        case doublesub:
          str = selfChang();
          isID = ISID();
          break;
        case FLOATCONSTANT:
        case DOUBLECONSTANT:
        case INTEGER_LITERAL:
          str = Integer();
          isID = ISID();
          break;
        case LC:
          jj_consume_token(LC);
          str = Express();
          jj_consume_token(RC);
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        if(!PanDuan(str) && isID && !fh.has(str))
                  {
                        String error = "Identifier " + str + " havn't been declared!";
                    appendMethodA(ErrorOutputName, error);
                  }
    {if (true) return str;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//判断是不是数组
  static final public boolean PanDuan(String s) throws ParseException {
 /*@bgen(jjtree) PanDuan */
  SimpleNode jjtn000 = new SimpleNode(JJTPANDUAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int i = s.length()-1;
    try {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    if(s.charAt(i)==']' || s.charAt(0)== 'T')
    {if (true) return true;}
    else
    {if (true) return false;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public boolean ISID() throws ParseException {
 /*@bgen(jjtree) ISID */
  SimpleNode jjtn000 = new SimpleNode(JJTISID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return false;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//数组
  static final public String array() throws ParseException {
 /*@bgen(jjtree) array */
  SimpleNode jjtn000 = new SimpleNode(JJTARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
  String length = "";
  String str = "";
    try {
      t = jj_consume_token(IDENTIFIER);
    str = t.image;
      label_15:
      while (true) {
        jj_consume_token(LT);
        length = Express();
        jj_consume_token(RT);
      str += "[" + length + "]";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_15;
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return str;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//前++和--
  static final public String selfChang() throws ParseException {
 /*@bgen(jjtree) selfChang */
  SimpleNode jjtn000 = new SimpleNode(JJTSELFCHANG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = "";
  String s = "";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
        jj_consume_token(doubleadd);
        s = "+";
        break;
      case doublesub:
        jj_consume_token(doublesub);
        s = "-";
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      str = Identifier();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      if(!fh.has(str))
                  {
                        String error = "Identifier " + str + " havn't been declared!";
                    appendMethodA(ErrorOutputName, error);
                  }
      qtTable.addQTInfo(new QTInfo(s, str, "1", str));
      {if (true) return str;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//后++和--
  static final public String afterChang() throws ParseException {
 /*@bgen(jjtree) afterChang */
  SimpleNode jjtn000 = new SimpleNode(JJTAFTERCHANG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = "";
  String s = "";
  String temp = "";
    try {
      //后自增
        str = Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
        jj_consume_token(doubleadd);
        s = "+";
        break;
      case doublesub:
        jj_consume_token(doublesub);
        s = "-";
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      temp = VariableNameGenerator.genVariableName();
      qtTable.addQTInfo(new QTInfo("=", str, "_", temp));
      qtTable.addQTInfo(new QTInfo(s, str, "1", str));
      {if (true) return temp;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String callFunc() throws ParseException {
 /*@bgen(jjtree) callFunc */
  SimpleNode jjtn000 = new SimpleNode(JJTCALLFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = "";
  String str1 = "";
  String s = "";
  QTInfo qtCall = null;
  Token t = null;
    try {
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LC);
    s = t.image;
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case doubleadd:
        case doublesub:
        case LC:
        case FLOATCONSTANT:
        case DOUBLECONSTANT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_16;
        }
        str1 = Express();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          jj_consume_token(comma);
          break;
        default:
          jj_la1[46] = jj_gen;
          ;
        }
      qtTable.addQTInfo(new QTInfo("para", str1, "_", "_"));
      }
      jj_consume_token(RC);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    s = VariableNameGenerator.genVariableName();
    qtTable.addQTInfo(new QTInfo("call", str, "_", s));
    {if (true) return s;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String Relation() throws ParseException {
 /*@bgen(jjtree) Relation */
  SimpleNode jjtn000 = new SimpleNode(JJTRELATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case less:
        t = jj_consume_token(less);
        break;
      case lessEqual:
        t = jj_consume_token(lessEqual);
        break;
      case over:
        t = jj_consume_token(over);
        break;
      case overEqual:
        t = jj_consume_token(overEqual);
        break;
      case equal:
        t = jj_consume_token(equal);
        break;
      case noEqual:
        t = jj_consume_token(noEqual);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String type() throws ParseException {
 /*@bgen(jjtree) type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        t = jj_consume_token(VOID);
        break;
      case Int:
        t = jj_consume_token(Int);
        break;
      case Double:
        t = jj_consume_token(Double);
        break;
      case Float:
        t = jj_consume_token(Float);
        break;
      case Char:
        t = jj_consume_token(Char);
        break;
      case Bool:
        t = jj_consume_token(Bool);
        break;
      case SHORT:
        t = jj_consume_token(SHORT);
        break;
      case LONG:
        t = jj_consume_token(LONG);
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//标识符函数
//此函数包括标识符后添加的各种字符
  static final public String Identifier() throws ParseException {
 /*@bgen(jjtree) Identifier */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
  String str = "";
  String length = "";
  String length1 = "";
  String length2 = "";
  int count = 0;
    try {
      //  LOOKAHEAD(2)
        t = jj_consume_token(IDENTIFIER);
    str = t.image;
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_17;
        }
        jj_consume_token(LT);
        length = Express();
        jj_consume_token(RT);
      //数组声明
      if (fh.has("notID"))
      {
        array a = new array(length);
        fh.get("notID").add(a);
      }
      //数组使用
      else
      {
        if(!fh.has(str))
                  {
                        String error = "Identifier " + str + " havn't been declared!";
                    appendMethodA(ErrorOutputName, error);
                  }
                else
                {

           if (count == 0)
           {
             length1 = length;
           }
           else if (count == 1)
         {
           length2 = length;
          }
         ++count;
        }
      }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    if (count == 1)
    {
      String T = VariableNameGenerator.genVariableName();
      int len = fh.get(t.image).v.get(0).length;
      qtTable.addQTInfo(new QTInfo("+", length1,"0", T));
      str = T;
    }
    else if (count == 2)
    {
      String T1 = VariableNameGenerator.genVariableName();
      String T2 = VariableNameGenerator.genVariableName();
      int len1 = fh.get(t.image).v.get(0).length;
      int len2 = fh.get(t.image).v.get(1).length;
      qtTable.addQTInfo(new QTInfo("*", length1, len1 + "", T1));
      qtTable.addQTInfo(new QTInfo("+", length2, T1, T1));
      qtTable.addQTInfo(new QTInfo("-", t.image, (len2 + 1) + "", T2));
      str = T2 + "[" + T1 + "]";
    }

    {if (true) return str;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//防止数组返回T[T]
  static final public String Identifier1() throws ParseException {
 /*@bgen(jjtree) Identifier1 */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      t = jj_consume_token(IDENTIFIER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//跳转语句
  static final public void jumpS() throws ParseException {
 /*@bgen(jjtree) jumpS */
  SimpleNode jjtn000 = new SimpleNode(JJTJUMPS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RETURN:
        ReturnS();
        break;
      case BREAK:
        BreakS();
        break;
      case CONTINUE:
        ContinueS();
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//返回语句
  static final public void ReturnS() throws ParseException {
 /*@bgen(jjtree) ReturnS */
  SimpleNode jjtn000 = new SimpleNode(JJTRETURNS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case doubleadd:
      case doublesub:
      case LC:
      case FLOATCONSTANT:
      case DOUBLECONSTANT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        Express();
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      jj_consume_token(semicolon);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//break语句
  static final public void BreakS() throws ParseException {
 /*@bgen(jjtree) BreakS */
  SimpleNode jjtn000 = new SimpleNode(JJTBREAKS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BREAK);
      jj_consume_token(semicolon);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//continue语句
  static final public void ContinueS() throws ParseException {
 /*@bgen(jjtree) ContinueS */
  SimpleNode jjtn000 = new SimpleNode(JJTCONTINUES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CONTINUE);
      jj_consume_token(semicolon);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//数字函数
//I:\eclipse_javacc\eclipse_javacc\java\BY\test.txt
  static final public String Integer() throws ParseException {
 /*@bgen(jjtree) Integer */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t = jj_consume_token(INTEGER_LITERAL);
        break;
      case FLOATCONSTANT:
        t = jj_consume_token(FLOATCONSTANT);
        break;
      case DOUBLECONSTANT:
        t = jj_consume_token(DOUBLECONSTANT);
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_3R_30() {
    if (jj_3R_36()) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3R_29() {
    if (jj_3R_35()) return true;
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_3R_34()) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_19()) return true;
    return false;
  }

  static private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_18()) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LC)) return true;
    return false;
  }

  static private boolean jj_3R_22() {
    if (jj_3R_23()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_24()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_37() {
    return false;
  }

  static private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_40() {
    if (jj_scan_token(doublesub)) return true;
    return false;
  }

  static private boolean jj_3R_33() {
    if (jj_scan_token(doublesub)) return true;
    return false;
  }

  static private boolean jj_3R_39() {
    if (jj_scan_token(doubleadd)) return true;
    return false;
  }

  static private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    }
    return false;
  }

  static private boolean jj_3R_32() {
    if (jj_scan_token(doubleadd)) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_scan_token(assign)) return true;
    return false;
  }

  static private boolean jj_3R_18() {
    if (jj_3R_20()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_38() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  static private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    if (jj_3R_34()) return true;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_3R_22()) return true;
    return false;
  }

  static private boolean jj_3R_23() {
    if (jj_3R_25()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_26()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_27()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_34() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_38()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_31() {
    if (jj_scan_token(LC)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public EG2TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[53];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x80,0x0,0x80000000,0x0,0x80000000,0x3073d00,0x3073d00,0x3073d00,0x3073d00,0x3000000,0x3000000,0x0,0x80000000,0x80000000,0x0,0x80000000,0x2100,0x0,0x3073d00,0x4000,0x3073d00,0x8000,0x200,0x40000000,0x20000000,0x7000000,0x0,0x1c00,0x3000000,0x7000000,0x3000000,0x3000000,0x18180000,0x18180000,0x3000000,0x3000000,0xe00000,0xe00000,0x3000000,0x3000000,0x3000000,0x0,0x3000000,0x3000000,0x3000000,0x0,0x0,0x0,0x0,0x70000,0x3000000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1fe000,0x0,0x1fe000,0x0,0x200000,0x0,0x1c5fe880,0x1c5fe880,0x1c5fe880,0x1c5fe080,0x1c1fe080,0x1c1fe080,0x200000,0x0,0x0,0x200000,0x0,0x0,0x11000000,0x1c5fe080,0x0,0x1c5fe080,0x0,0x0,0x0,0x0,0x1c000080,0x3f,0x0,0x1c000080,0x1c000080,0x1c000080,0x1c000080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c000080,0x200,0x0,0x0,0x1c000080,0x200000,0x3f,0x1fe000,0x200,0x0,0x1c000080,0x1c000000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[2];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public EG2(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public EG2(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new EG2TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public EG2(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new EG2TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public EG2(EG2TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(EG2TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[67];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 53; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 67; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
